<!DOCTYPE html>
<html>
<head>
  <title>üêù Bee Bay C√πng B·∫°n - Nhanh Tay L·∫π M·∫Øt</title>
  <style>
    body {
      /* --- 1. S·ª¨A L·ªñI FONT CH·ªÆ (R√ï R√ÄNG H∆†N) --- */
      font-family: 'Arial', sans-serif;
      font-weight: bold; /* L√†m ch·ªØ ƒë·∫≠m, d·ªÖ ƒë·ªçc h∆°n */
      
      background: linear-gradient(135deg, #87CEEB, #98FB98, #FFE4B5);
      margin: 0;
      padding: 20px;
      text-align: center;
      min-height: 100vh;
    }
    
    .game-container {
      background: rgba(255, 255, 255, 0.9);
      border-radius: 20px;
      padding: 20px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.2);
      display: inline-block;
      margin: 10px;
    }
    
    h1 {
      font-size: 1.8rem;
      color: #2E8B57;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
      margin: 10px 0;
      animation: bounce 2s ease-in-out infinite;
    }
    
    @keyframes bounce {
      0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
      40% { transform: translateY(-10px); }
      60% { transform: translateY(-5px); }
    }
    
    .instruction {
      font-size: 1rem;
      color: #4169E1;
      margin: 15px 0;
      font-weight: bold;
      background: linear-gradient(135deg, #E6E6FA, #F0F8FF);
      padding: 10px;
      border-radius: 15px;
      border: 3px solid #9370DB;
    }
    
    .space-key {
      display: inline-block;
      background: #4169E1;
      color: white;
      padding: 8px 20px;
      border-radius: 10px;
      font-size: 1.3rem;
      font-weight: bold;
      margin: 0 5px;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
    }
    
    canvas {
      border: 4px solid #FFD700;
      border-radius: 15px;
      display: block;
      margin: 20px auto;
      background: linear-gradient(to bottom, #87CEEB, #98FB98);
      box-shadow: 0 8px 25px rgba(0,0,0,0.4);
      cursor: pointer;
    }
    
    canvas:hover {
      box-shadow: 0 10px 30px rgba(0,0,0,0.5);
      transform: translateY(-2px);
      transition: all 0.3s ease;
    }
    
    .score-display {
      font-size: 1.15rem;
      color: #2E8B57;
      font-weight: bold;
      margin: 10px;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
    }
    
    .game-over {
      background: rgba(255, 182, 193, 0.9);
      padding: 20px;
      border-radius: 15px;
      margin: 20px;
      border: 3px solid #FF69B4;
    }
    
    .encouragement {
      font-size: 1.6rem;
      color: #FF1493;
      font-weight: bold;
      margin: 15px 0;
      animation: pulse 1.5s ease-in-out infinite;
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    
    .button {
      background: linear-gradient(135deg, #32CD32, #228B22);
      color: white;
      border: none;
      padding: 15px 30px;
      font-size: 1.4rem;
      font-weight: bold;
      border-radius: 25px;
      cursor: pointer;
      margin: 10px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
      transition: transform 0.2s ease;
    }
    
    .button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0,0,0,0.4);
    }
    
    .mode-selector {
      margin: 20px 0;
    }
    
    .mode-button {
      background: linear-gradient(135deg, #FFB347, #FF8C69);
      margin: 5px;
      padding: 10px 20px;
      font-size: 0.95rem;
    }
    
    .mode-button.active {
      background: linear-gradient(135deg, #32CD32, #228B22);
    }
    
    .audio-controls {
      margin: 15px 0;
    }
    
    .audio-button {
      background: linear-gradient(135deg, #27ae60, #2ecc71);
      margin: 5px;
      padding: 8px 16px;
      font-size: 1rem;
    }
  </style>
</head>
<body>
  <div class="game-container">
    <h1>üêù Bee Bay C√πng B·∫°n!</h1>
    
    <div class="instruction">
      Nh·∫•n ph√≠m <span class="space-key">SPACE</span> ƒë·ªÉ gi√∫p Bee nh·∫£y qua ch∆∞·ªõng ng·∫°i v·∫≠t! üéà
      <br>üêù‚¨ÜÔ∏è H√£y gi√∫p Bee bay cao cao nh√©! ‚ú®
    </div>
    
    <div class="mode-selector">
      <button class="button mode-button active" onclick="setGameMode('easy')">üåü Si√™u D·ªÖ</button>
      <button class="button mode-button" onclick="setGameMode('normal')">‚≠ê B√¨nh Th∆∞·ªùng</button>
    </div>
    
    <div class="audio-controls">
      <button id="audioToggle" class="button audio-button" onclick="toggleAudio()">üîä √Çm thanh: B·∫≠t</button>
      <button id="musicToggle" class="button audio-button" onclick="toggleBackgroundMusic()">üéµ B·∫≠t nh·∫°c n·ªÅn</button>
    </div>
    
    <div class="score-display">
      <span id="currentScore">ƒêi·ªÉm hi·ªán t·∫°i: 0</span> | 
      <span id="highScore">ƒêi·ªÉm cao nh·∫•t: 0</span>
    </div>
    
    <canvas id="gameCanvas" width="600" height="400"></canvas>
    
    <div id="gameOverScreen" class="game-over" style="display: none;">
      <div class="encouragement" id="encouragementMessage">B·∫°n ƒë√£ c·ªë g·∫Øng r·∫•t t·ªët! üåü</div>
      <button class="button" onclick="restartGame()">üîÑ C√πng Bee th·ª≠ l·∫°i nh√©!</button>
      <button class="button" onclick="speakEncouragement()" style="background: linear-gradient(135deg, #9370DB, #8A2BE2);">üîä ƒê·ªçc to</button>
    </div>
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    // (Gi·ªØ nguy√™n code logic game)
    let gameMode = 'easy'; 
    let gameRunning = false;
    let gameStarted = false;
    let obstacleSpawnTimer;
    let animationId;
    const gameSettings = {
      easy: { obstacleSpeed: 3, spawnInterval: 2500, gravity: 0.35, jumpPower: -8 },
      normal: { obstacleSpeed: 5, spawnInterval: 1500, gravity: 0.5, jumpPower: -10 }
    };
    let player = { x: 80, y: 200, width: 40, height: 40, gravity: gameSettings.easy.gravity, velocity: 0, isJumping: false };
    let obstacles = [];
    let score = 0;
    let highScore = localStorage.getItem('beeGameHighScore') || 0;
    const encouragementMessages = [
      "B·∫°n ƒë√£ c·ªë g·∫Øng r·∫•t t·ªët! üåü",
      "Tuy·ªát v·ªùi! Bee r·∫•t t·ª± h√†o v·ªÅ b·∫°n! üêù‚ú®", 
      "Kh√¥ng sao ƒë√¢u, c√πng th·ª≠ l·∫°i nh√©! üí™",
      "B·∫°n ƒëang h·ªçc h·ªèi v√† ti·∫øn b·ªô m·ªói ng√†y! üåà",
      "Bee tin b·∫°n s·∫Ω l√†m ƒë∆∞·ª£c! üåü",
      "M·ªói l·∫ßn th·ª≠ l√† m·ªôt b∆∞·ªõc ti·∫øn! üéà"
    ];

    // (Gi·ªØ nguy√™n code √¢m thanh)
    let audioContext;
    let audioEnabled = true;
    let backgroundMusic = null;
    let musicPlaying = false;
    function initAudio() { try { audioContext = new (window.AudioContext || window.webkitAudioContext)(); if (audioContext.state === 'suspended') { audioContext.resume(); } createBackgroundMusic(); } catch(e) { audioContext = null; } }
    function createBackgroundMusic() { /* (code nh·∫°c n·ªÅn gi·∫£ l·∫≠p) */ }
    function playMusicNote(frequency, duration) { /* (code nh·∫°c n·ªÅn) */ }
    function toggleBackgroundMusic() { if (!audioContext) { initAudio(); } musicPlaying = !musicPlaying; const button = document.getElementById('musicToggle'); if (musicPlaying) { button.textContent = 'üéµ T·∫Øt nh·∫°c n·ªÅn'; button.style.background = 'linear-gradient(135deg, #FF6B6B, #4ECDC4)'; if (backgroundMusic) { backgroundMusic(); } } else { button.textContent = 'üéµ B·∫≠t nh·∫°c n·ªÅn'; button.style.background = 'linear-gradient(135deg, #95a5a6, #bdc3c7)'; } }
    function playSound(frequency, duration, type = 'sine', volume = 0.1) { if (!audioEnabled) return; if (audioContext && audioContext.state !== 'suspended') { try { const oscillator = audioContext.createOscillator(); const gainNode = audioContext.createGain(); oscillator.connect(gainNode); gainNode.connect(audioContext.destination); oscillator.frequency.value = frequency; oscillator.type = type; gainNode.gain.setValueAtTime(0, audioContext.currentTime); gainNode.gain.exponentialRampToValueAtTime(volume, audioContext.currentTime + 0.01); gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration); oscillator.start(); oscillator.stop(audioContext.currentTime + duration); return; } catch(e) {} } try { const sampleRate = 8000; const samples = duration * sampleRate; const buffer = new ArrayBuffer(44 + samples * 2); const view = new DataView(buffer); const writeString = (offset, string) => { for (let i = 0; i < string.length; i++) { view.setUint8(offset + i, string.charCodeAt(i)); } }; writeString(0, 'RIFF'); view.setUint32(4, 36 + samples * 2, true); writeString(8, 'WAVE'); writeString(12, 'fmt '); view.setUint32(16, 16, true); view.setUint16(20, 1, true); view.setUint16(22, 1, true); view.setUint32(24, sampleRate, true); view.setUint32(28, sampleRate * 2, true); view.setUint16(32, 2, true); view.setUint16(34, 16, true); writeString(36, 'data'); view.setUint32(40, samples * 2, true); for (let i = 0; i < samples; i++) { const sample = Math.sin(frequency * 2 * Math.PI * i / sampleRate) * volume * 32767; view.setInt16(44 + i * 2, sample, true); } const blob = new Blob([buffer], { type: 'audio/wav' }); const url = URL.createObjectURL(blob); const audio = new Audio(url); audio.volume = 0.3; audio.play().catch(e => {}); audio.onended = () => { URL.revokeObjectURL(url); }; } catch(e) {} }
    function toggleAudio() { audioEnabled = !audioEnabled; const button = document.getElementById('audioToggle'); if (audioEnabled) { button.textContent = 'üîä √Çm thanh: B·∫≠t'; button.style.background = 'linear-gradient(135deg, #27ae60, #2ecc71)'; } else { button.textContent = 'üîá √Çm thanh: T·∫Øt'; button.style.background = 'linear-gradient(135deg, #e74c3c, #c0392b)'; musicPlaying = false; document.getElementById('musicToggle').textContent = 'üéµ B·∫≠t nh·∫°c n·ªÅn'; } }
    
    // --- üî¥ PH·∫¶N ƒê√É S·ª¨A: H√ÄM ƒê·ªåC VƒÇN B·∫¢N M·ªöI ---
    function speakText(text) { 
        if ('speechSynthesis' in window) { 
            // 1. L·ªçc b·ªè icon/emoji ƒë·ªÉ kh√¥ng b·ªã ƒë·ªçc ti·∫øng Anh
            const cleanText = text.replace(/([\u2700-\u27BF]|[\uE000-\uF8FF]|\uD83C[\uDC00-\uDFFF]|\uD83D[\uDC00-\uDFFF]|[\u2011-\u26FF]|\uD83E[\uDD10-\uDDFF])/g, '').trim();

            // 2. D·ª´ng c√°c √¢m thanh ƒëang ƒë·ªçc d·ªü
            window.speechSynthesis.cancel();

            const utterance = new SpeechSynthesisUtterance(cleanText);
            
            // 3. C·ªë ƒë·ªãnh ti·∫øng Vi·ªát
            utterance.lang = 'vi-VN'; 
            utterance.rate = 1.0; 

            // Ph√°t √¢m thanh
            window.speechSynthesis.speak(utterance); 
        } 
    }

    function speakEncouragement() { 
        const message = document.getElementById('encouragementMessage').textContent; 
        speakText(message); 
    }
    
    function updateScoreDisplay() { document.getElementById('currentScore').textContent = `ƒêi·ªÉm hi·ªán t·∫°i: ${score}`; document.getElementById('highScore').textContent = `ƒêi·ªÉm cao nh·∫•t: ${highScore}`; }
    function setGameMode(mode) { gameMode = mode; player.gravity = gameSettings[mode].gravity; log(`Game mode changed to: ${mode}`, 'info'); document.querySelectorAll('.mode-button').forEach(btn => { btn.classList.remove('active'); }); event.target.classList.add('active'); }
    
    // (Gi·ªØ nguy√™n code v·∫Ω ong v√† ch∆∞·ªõng ng·∫°i v·∫≠t)
    function drawBee() {
      const gradient = ctx.createRadialGradient( player.x + player.width/2, player.y + player.height/2, 5, player.x + player.width/2, player.y + player.height/2, player.width/2 ); gradient.addColorStop(0, "#FFFF00"); gradient.addColorStop(1, "#FFD700"); ctx.fillStyle = gradient; ctx.beginPath(); ctx.arc(player.x + player.width/2, player.y + player.height/2, player.width/2, 0, 2 * Math.PI); ctx.fill();
      ctx.fillStyle = "#000000"; ctx.fillRect(player.x + 6, player.y + 8, 6, 24); ctx.fillRect(player.x + 16, player.y + 8, 6, 24); ctx.fillRect(player.x + 28, player.y + 8, 6, 24);
      const wingOffset = Math.sin(Date.now() * 0.03) * 3; const wingGradient = ctx.createLinearGradient(player.x - 8, player.y, player.x + 20, player.y); wingGradient.addColorStop(0, "rgba(255, 255, 255, 0.9)"); wingGradient.addColorStop(1, "rgba(240, 248, 255, 0.7)"); ctx.fillStyle = wingGradient; ctx.fillRect(player.x - 8, player.y + 4 + wingOffset, 18, 10); ctx.fillRect(player.x + player.width - 12, player.y + 4 - wingOffset, 18, 10);
      ctx.fillStyle = "#FFFFFF"; ctx.beginPath(); ctx.arc(player.x + 12, player.y + 12, 5, 0, 2 * Math.PI); ctx.arc(player.x + 28, player.y + 12, 5, 0, 2 * Math.PI); ctx.fill();
      ctx.fillStyle = "#000000"; ctx.beginPath(); ctx.arc(player.x + 12, player.y + 12, 3, 0, 2 * Math.PI); ctx.arc(player.x + 28, player.y + 12, 3, 0, 2 * Math.PI); ctx.fill();
      ctx.fillStyle = "#FFFFFF"; ctx.beginPath(); ctx.arc(player.x + 13, player.y + 11, 1, 0, 2 * Math.PI); ctx.arc(player.x + 29, player.y + 11, 1, 0, 2 * Math.PI); ctx.fill();
    }
    function drawObstacle(obstacle) {
      const colors = ["#FF1493", "#00BFFF", "#32CD32", "#FF6347", "#9932CC", "#FF69B4", "#1E90FF", "#00FF7F", "#FF4500", "#8A2BE2"]; const colorIndex = obstacle.colorIndex || 0;
      ctx.fillStyle = "rgba(0, 0, 0, 0.3)"; ctx.beginPath(); ctx.arc(obstacle.x + obstacle.width/2 + 2, obstacle.y + 17, 12, 0, 2 * Math.PI); ctx.fill();
      const balloonGradient = ctx.createRadialGradient( obstacle.x + obstacle.width/2 - 3, obstacle.y + 12, 2, obstacle.x + obstacle.width/2, obstacle.y + 15, 12 ); balloonGradient.addColorStop(0, "#FFFFFF"); balloonGradient.addColorStop(0.3, colors[colorIndex]); balloonGradient.addColorStop(1, colors[colorIndex]); ctx.fillStyle = balloonGradient; ctx.beginPath(); ctx.arc(obstacle.x + obstacle.width/2, obstacle.y + 15, 12, 0, 2 * Math.PI); ctx.fill();
      ctx.strokeStyle = "#333333"; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(obstacle.x + obstacle.width/2, obstacle.y + 15, 12, 0, 2 * Math.PI); ctx.stroke();
      ctx.strokeStyle = "#4A4A4A"; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(obstacle.x + obstacle.width/2, obstacle.y + 27); ctx.lineTo(obstacle.x + obstacle.width/2, obstacle.y + obstacle.height); ctx.stroke();
      ctx.fillStyle = "rgba(255, 255, 255, 0.6)"; ctx.beginPath(); ctx.arc(obstacle.x + obstacle.width/2 - 3, obstacle.y + 12, 4, 0, 2 * Math.PI); ctx.fill();
      ctx.strokeStyle = "#000000"; ctx.lineWidth = 1; ctx.fillStyle = "#000000";
      
      // --- 1. S·ª¨A L·ªñI FONT CH·ªÆ ---
      ctx.font = "bold 14px Arial"; 
      ctx.textAlign = "center"; ctx.strokeText("üòä", obstacle.x + obstacle.width/2, obstacle.y + 21); ctx.fillText("üòä", obstacle.x + obstacle.width/2, obstacle.y + 21);
    }

    // (Gi·ªØ nguy√™n code logic game)
    function handlePlayerJump() { if (!gameRunning && !gameStarted) { startGame(); player.velocity = gameSettings[gameMode].jumpPower; player.isJumping = true; playSound(600, 0.15, 'square', 0.2); return; } if (gameRunning) { player.velocity = gameSettings[gameMode].jumpPower; player.isJumping = true; playSound(600, 0.15, 'square', 0.2); } }
    function updatePlayer() { player.velocity += player.gravity; player.y += player.velocity; if (player.y + player.height > canvas.height - 20) { player.y = canvas.height - 20 - player.height; player.velocity = 0; player.isJumping = false; } if (player.y < 0) { player.y = 0; player.velocity = 0; } }
    function spawnObstacle() { if (!gameRunning) return; const obstacleHeight = Math.random() * 60 + 40; const obstacle = { x: canvas.width, y: canvas.height - 20 - obstacleHeight, width: 25, height: obstacleHeight, colorIndex: Math.floor(Math.random() * 5) }; obstacles.push(obstacle); }
    function updateObstacles() { const currentSpeed = gameSettings[gameMode].obstacleSpeed; for (let i = obstacles.length - 1; i >= 0; i--) { obstacles[i].x -= currentSpeed; if (obstacles[i].x + obstacles[i].width < 0) { obstacles.splice(i, 1); score++; updateScoreDisplay(); playSound(800, 0.2, 'sine', 0.15); if (score > 0 && score % 5 === 0) { showMilestoneMessage(); } } if (obstacles[i] && player.x < obstacles[i].x + obstacles[i].width - 5 && player.x + player.width - 5 > obstacles[i].x && player.y < obstacles[i].y + obstacles[i].height - 5 && player.y + player.height - 5 > obstacles[i].y ) { endGame(); break; } } }
    function showMilestoneMessage() { const milestone = document.createElement('div'); milestone.textContent = `Tuy·ªát v·ªùi! ${score} ƒëi·ªÉm! üåü`; milestone.style.cssText = ` position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(255, 215, 0, 0.9); color: #2E8B57; padding: 15px 30px; border-radius: 20px; font-size: 1.5rem; font-weight: bold; z-index: 1000; animation: fadeInOut 2s ease-in-out forwards; `; const style = document.createElement('style'); style.textContent = ` @keyframes fadeInOut { 0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); } 50% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); } 100% { opacity: 0; transform: translate(-50%, -50%) scale(1); } } `; document.head.appendChild(style); document.body.appendChild(milestone); setTimeout(() => { document.body.removeChild(milestone); document.head.removeChild(style); }, 2000); }
    function drawBackground() { const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height); gradient.addColorStop(0, "#4A90E2"); gradient.addColorStop(0.7, "#87CEEB"); gradient.addColorStop(1, "#98FB98"); ctx.fillStyle = gradient; ctx.fillRect(0, 0, canvas.width, canvas.height); ctx.fillStyle = "rgba(255, 255, 255, 0.9)"; ctx.strokeStyle = "rgba(200, 200, 200, 0.5)"; ctx.lineWidth = 1; ctx.beginPath(); const cloud1X = 120 + Math.sin(Date.now() * 0.001) * 30; ctx.arc(cloud1X, 50, 20, 0, 2 * Math.PI); ctx.arc(cloud1X + 25, 50, 25, 0, 2 * Math.PI); ctx.arc(cloud1X + 15, 35, 15, 0, 2 * Math.PI); ctx.fill(); ctx.stroke(); ctx.beginPath(); const cloud2X = 350 + Math.sin(Date.now() * 0.0008) * 25; ctx.arc(cloud2X, 70, 18, 0, 2 * Math.PI); ctx.arc(cloud2X + 30, 70, 22, 0, 2 * Math.PI); ctx.arc(cloud2X + 20, 55, 18, 0, 2 * Math.PI); ctx.fill(); ctx.stroke(); ctx.beginPath(); const cloud3X = 480 + Math.sin(Date.now() * 0.0012) * 20; ctx.arc(cloud3X, 45, 12, 0, 2 * Math.PI); ctx.arc(cloud3X + 18, 45, 15, 0, 2 * Math.PI); ctx.arc(cloud3X + 10, 35, 10, 0, 2 * Math.PI); ctx.fill(); ctx.stroke(); const groundGradient = ctx.createLinearGradient(0, canvas.height - 20, 0, canvas.height); groundGradient.addColorStop(0, "#228B22"); groundGradient.addColorStop(1, "#006400"); ctx.fillStyle = groundGradient; ctx.fillRect(0, canvas.height - 20, canvas.width, 20); ctx.strokeStyle = "rgba(0, 100, 0, 0.3)"; ctx.lineWidth = 1; for (let i = 0; i < canvas.width; i += 30) { ctx.beginPath(); ctx.moveTo(i, canvas.height - 20); ctx.lineTo(i + 15, canvas.height); ctx.stroke(); } }

    function drawScore() {
      ctx.fillStyle = "rgba(0, 0, 0, 0.6)"; ctx.fillRect(10, 10, 180, 70);
      ctx.fillStyle = "rgba(255, 255, 255, 0.9)"; ctx.fillRect(12, 12, 176, 66);
      ctx.fillStyle = "#2E8B57";
      // --- 1. S·ª¨A L·ªñI FONT CH·ªÆ ---
      ctx.font = "bold 24px Arial";
      ctx.textAlign = "left"; ctx.fillText(`üèÜ ${score}`, 20, 40);
      if (score > 0 || highScore > 0) {
        ctx.fillStyle = "#FF6347";
        // --- 1. S·ª¨A L·ªñI FONT CH·ªÆ ---
        ctx.font = "bold 16px Arial";
        ctx.fillText(`üåü Cao nh·∫•t: ${highScore}`, 20, 65);
      }
      ctx.fillStyle = "#4169E1";
      // --- 1. S·ª¨A L·ªñI FONT CH·ªÆ ---
      ctx.font = "bold 14px Arial";
      ctx.textAlign = "right"; const modeText = gameMode === 'easy' ? 'üåü Si√™u D·ªÖ' : '‚≠ê B√¨nh Th∆∞·ªùng'; ctx.fillText(modeText, canvas.width - 20, 40);
      if (gameRunning && Date.now() % 1000 < 16) { ctx.fillStyle = "#888888"; ctx.font = "10px Arial"; ctx.fillText(`FPS: ${Math.round(1000/16)}`, canvas.width - 70, 60); }
    }

    function endGame() {
      gameRunning = false; gameStarted = false;
      log(`Game ended. Final score: ${score}, High score: ${Math.max(score, highScore)}`, 'info');
      if (score > highScore) { highScore = score; localStorage.setItem('beeGameHighScore', highScore); updateScoreDisplay(); log(`New high score achieved: ${highScore}!`, 'success'); }
      playSound(300, 0.3, 'sawtooth', 0.1); setTimeout(() => playSound(250, 0.3, 'sawtooth', 0.08), 200); setTimeout(() => playSound(200, 0.4, 'sawtooth', 0.06), 400);
      if (obstacleSpawnTimer) { clearInterval(obstacleSpawnTimer); }
      if (animationId) { cancelAnimationFrame(animationId); }
      const randomMessage = encouragementMessages[Math.floor(Math.random() * encouragementMessages.length)];
      document.getElementById('encouragementMessage').textContent = randomMessage;
      document.getElementById('gameOverScreen').style.display = 'block';
    }
    function gameLoop() { if (!gameRunning) return; drawBackground(); updatePlayer(); updateObstacles(); drawBee(); obstacles.forEach(drawObstacle); drawScore(); animationId = requestAnimationFrame(gameLoop); }
    function startGame() {
      gameRunning = true; gameStarted = true; score = 0; obstacles = []; player.y = 200; player.velocity = 0;
      log(`Game started in ${gameMode} mode`, 'success');
      updateScoreDisplay(); document.getElementById('gameOverScreen').style.display = 'none';
      if (!audioContext) { initAudio(); }
      obstacleSpawnTimer = setInterval(spawnObstacle, gameSettings[gameMode].spawnInterval);
      gameLoop();
    }
    function restartGame() { startGame(); }

    document.addEventListener("keydown", (e) => { if (e.code === "Space") { e.preventDefault(); handlePlayerJump(); } });
    canvas.addEventListener("touchstart", (e) => { e.preventDefault(); handlePlayerJump(); });

    // (Gi·ªØ nguy√™n code Debug)
    let debugMode = localStorage.getItem('beeGameDebug') === 'true';
    let gameLog = [];
    function log(message, type = 'info') { const timestamp = new Date().toLocaleTimeString(); const logEntry = { timestamp, message, type }; gameLog.push(logEntry); if (gameLog.length > 50) { gameLog = gameLog.slice(-50); } console.log(`[${timestamp}] ${type.toUpperCase()}: ${message}`); if (debugMode) { const debugPanel = document.getElementById('debugPanel'); if (debugPanel) { updateDebugPanel(); } } }
    function toggleDebugMode() { debugMode = !debugMode; localStorage.setItem('beeGameDebug', debugMode); if (debugMode) { createDebugPanel(); log('Debug mode enabled', 'info'); } else { removeDebugPanel(); log('Debug mode disabled', 'info'); } }
    function createDebugPanel() { /* (code debug) */ } function updateDebugPanel() { /* (code debug) */ } function getLogColor(type) { /* (code debug) */ } function removeDebugPanel() { /* (code debug) */ } function exportGameLog() { /* (code debug) */ }
    log('Game initialized', 'info'); log(`Browser: ${navigator.userAgent}`, 'info'); log(`Screen: ${screen.width}x${screen.height}`, 'info');
    document.addEventListener('keydown', (e) => { if (e.ctrlKey && e.key === 'd') { e.preventDefault(); toggleDebugMode(); } });
    
    updateScoreDisplay();
    drawBackground();
    drawBee();
    
    ctx.fillStyle = "rgba(0, 0, 0, 0.7)"; ctx.fillRect(canvas.width/2 - 150, canvas.height/2 - 40, 300, 80);
    ctx.fillStyle = "rgba(255, 255, 255, 0.95)"; ctx.fillRect(canvas.width/2 - 145, canvas.height/2 - 35, 290, 70);
    ctx.fillStyle = "#4169E1";
    // --- 1. S·ª¨A L·ªñI FONT CH·ªÆ ---
    ctx.font = "bold 22px Arial";
    ctx.textAlign = "center"; ctx.fillText("Nh·∫•n SPACE ƒë·ªÉ b·∫Øt ƒë·∫ßu!", canvas.width/2, canvas.height/2 - 5);
    ctx.fillStyle = "#2E8B57";
    // --- 1. S·ª¨A L·ªñI FONT CH·ªÆ ---
    ctx.font = "bold 16px Arial";
    ctx.fillText("Ho·∫∑c nh·∫•n v√†o m√†n h√¨nh üì±", canvas.width/2, canvas.height/2 + 20);
  </script>
</body>
</html>
