# pages/8_üí¨_Tr√≤_chuy·ªán.py
import asyncio
import base64
import html
import os
import random
import re
import time
from datetime import datetime
from io import BytesIO

import pandas as pd
import streamlit as st

# Optional: Gemini
try:
    import google.generativeai as genai
    GENAI_AVAILABLE = True
except Exception:
    GENAI_AVAILABLE = False

# Fallback TTS
try:
    from gtts import gTTS
    GTTS_AVAILABLE = True
except Exception:
    GTTS_AVAILABLE = False

# Preferred neural TTS (Microsoft Edge TTS)
try:
    import edge_tts
    EDGE_TTS_AVAILABLE = True
except Exception:
    EDGE_TTS_AVAILABLE = False


# ========== 0) H·∫∞NG S·ªê V√Ä TR·∫†NG TH√ÅI ==========

STATE_CHAT = "chat"
STATE_JOURNAL = "journal"
STATE_RELAX = "relax"

CHAT_STATE_MAIN = "main"
CHAT_STATE_TAM_SU_SELECTION = "tam_su_selection"
CHAT_STATE_TAM_SU_CHAT = "tam_su_chat"
CHAT_STATE_GIAO_TIEP_SELECTION_BASIC = "giao_tiep_selection_basic"
CHAT_STATE_GIAO_TIEP_SELECTION_EXTENDED = "giao_tiep_selection_extended"
CHAT_STATE_GIAO_TIEP_PRACTICE = "giao_tiep_practice"
CHAT_STATE_AWAITING_FOLLOWUP = "awaiting_followup"

# ========== 1) C·∫§U H√åNH UI & CSS ==========

st.set_page_config(page_title="üí¨ Tr√≤ chuy·ªán", page_icon="üí¨", layout="wide")

st.markdown(
    """
<style>
/* Reset chrome */
#MainMenu, footer, header { visibility: hidden; }

/* Layout */
.stApp { background-color: #FFFFFF; }
.chat-shell { max-width: 820px; margin: 0 auto; padding-top: 64px; padding-bottom: 120px; }

/* Header sticky gi·ªëng app shopping */
.chat-header {
  position: fixed; top: 0; left: 0; right: 0; z-index: 999;
  background: #fff; border-bottom: 1px solid #efefef;
}
.chat-header-inner {
  max-width: 820px; margin: 0 auto; padding: 12px 16px;
  display: flex; align-items: center; gap: 12px;
}
.chat-title { font-weight: 700; font-size: 1.05rem; }

/* Bubbles */
.bubble-row { display:flex; margin: 8px 0; }
.bubble-user { justify-content: flex-end; }
.msg {
  border-radius: 18px; padding: 10px 14px; max-width: 70%;
  font-size: 1rem; line-height: 1.5; word-wrap: break-word;
}
.msg-user { background: #DCF8C6; color: #101010; border-top-right-radius: 6px; }
.msg-bot  { background: #F3F4F6; color: #111; border-top-left-radius: 6px; }

/* Typing indicator */
.typing { display:inline-block; }
.typing span {
  height: 8px; width: 8px; margin: 0 2px; background-color: #9E9E9E;
  display: inline-block; border-radius: 50%; opacity: 0.5; animation: bob 1s infinite;
}
@keyframes bob { 0%,100%{transform:translateY(0)} 50%{transform:translateY(-6px)} }
.typing span:nth-child(1){animation-delay:-0.3s} .typing span:nth-child(2){animation-delay:-0.15s}

/* Quick actions (chips) */
.quick-actions { display:flex; gap:8px; flex-wrap: wrap; margin: 6px 0 12px; }
.quick-actions .chip {
  border: 1px solid #0084FF; color: #0084FF; background:#E7F3FF;
  border-radius: 16px; padding: 6px 10px; font-size: 0.9rem; cursor: pointer;
}
.quick-actions .chip:hover { background:#0084FF; color:#fff; }

/* Sticky input */
.input-bar {
  position: fixed; left: 0; right: 0; bottom: 0; z-index: 999;
  background: #fff; border-top: 1px solid #efefef;
}
.input-inner {
  max-width: 820px; margin: 0 auto; padding: 10px 12px;
}
</style>
""",
    unsafe_allow_html=True,
)

# Header
st.markdown(
    """
<div class="chat-header">
  <div class="chat-header-inner">
    <div>üõçÔ∏è</div>
    <div class="chat-title">Tr√≤ chuy·ªán - B·∫°n ƒê·ªìng H√†nh</div>
  </div>
</div>
""",
    unsafe_allow_html=True,
)


# ========== 2) CONFIG D·ªÆ LI·ªÜU N·ªòI DUNG ==========

@st.cache_data
def get_config():
    return {
        "ui": {
            "title": "B·∫°n ƒë·ªìng h√†nh üíñ",
            "input_placeholder": "Nh·∫≠p tin nh·∫Øn‚Ä¶",
        },
        "tam_su": {
            "intro_message": "H√¥m nay b·∫°n c·∫£m th·∫•y nh∆∞ th·∫ø n√†o n√®? M√¨nh lu√¥n s·∫µn l√≤ng l·∫Øng nghe b·∫°n nha üåü",
            "positive_affirmation_trigger": "üåº Nghe m·ªôt l·ªùi t√≠ch c·ª±c",
            "positive_affirmations": [
                "B·∫°n m·∫°nh m·∫Ω h∆°n b·∫°n nghƒ© r·∫•t nhi·ªÅu.",
                "M·ªói b∆∞·ªõc nh·ªè b·∫°n ƒëi ƒë·ªÅu l√† m·ªôt th√†nh c√¥ng l·ªõn.",
                "C·∫£m x√∫c c·ªßa b·∫°n l√† th·∫≠t v√† ƒë√°ng ƒë∆∞·ª£c t√¥n tr·ªçng.",
                "B·∫°n x·ª©ng ƒë√°ng ƒë∆∞·ª£c y√™u th∆∞∆°ng v√† h·∫°nh ph√∫c.",
                "H√¥m nay c√≥ th·ªÉ kh√≥ khƒÉn, nh∆∞ng ng√†y mai s·∫Ω t·ªët h∆°n."
            ],
            "moods": {
                "üòÑ Vui": {
                    "keywords": ["vui", "h·∫°nh ph√∫c", "tuy·ªát v·ªùi", "gi·ªèi", "ƒëi ch∆°i", "üéâ", "üòÑ"],
                    "initial": "Tuy·ªát v·ªùi qu√°! C√≥ chuy·ªán g√¨ vui kh√¥ng, k·ªÉ m√¨nh nghe v·ªõi n√®!",
                    "styles": {
                        "Khuy·∫øn kh√≠ch": [
                            "Nghe l√† th·∫•y vui gi√πm b·∫°n lu√¥n √°! K·ªÉ th√™m ch√∫t n·ªØa ƒëi!",
                            "H√¥m nay ch·∫Øc l√† m·ªôt ng√†y ƒë·∫∑c bi·ªát r·ªìi! Chia s·∫ª th√™m nh√©!"
                        ]
                    }
                },
                "üòî Bu·ªìn": {
                    "keywords": ["bu·ªìn", "ch√°n", "stress", "c√¥ ƒë∆°n", "t·ªá", "üòî"],
                    "initial": "√îi, m√¨nh nghe r·ªìi n√®. C√≥ chuy·ªán g√¨ l√†m b·∫°n bu·ªìn v·∫≠y?",
                    "styles": {
                        "L·∫Øng nghe": [
                            "Kh√¥ng sao ƒë√¢u, b·∫°n bu·ªìn c≈©ng ƒë∆∞·ª£c m√†. K·ªÉ m√¨nh nghe th√™m nh√©.",
                            "B·∫°n kh√¥ng c·∫ßn ph·∫£i g·ªìng ƒë√¢u, m√¨nh ·ªü ƒë√¢y n√®."
                        ]
                    }
                }
            }
        },
        "giao_tiep": {
            "intro_message": "H√£y ch·ªçn m·ªôt t√¨nh hu·ªëng b√™n d∆∞·ªõi ƒë·ªÉ m√¨nh c√πng luy·ªán t·∫≠p nh√©!",
            "confirm_buttons": {"understood": "‚úÖ ƒê√£ hi·ªÉu!", "not_understood": "‚ùì Ch∆∞a r√µ l·∫Øm!"},
            "scenarios_basic": {
                "üëã Ch√†o h·ªèi b·∫°n b√®": "B·∫°n c√≥ th·ªÉ n√≥i: ‚ÄúCh√†o b·∫°n, h√¥m nay vui kh√¥ng?‚Äù",
                "üôã H·ªèi b√†i th·∫ßy c√¥": "B·∫°n th·ª≠ h·ªèi: ‚ÄúTh·∫ßy/c√¥ ∆°i, ph·∫ßn n√†y em ch∆∞a r√µ ·∫°?‚Äù"
            },
            "scenarios_extended": {
                "üìö Nh·ªù b·∫°n gi√∫p ƒë·ª°": "B·∫°n th·ª≠ n√≥i: ‚ÄúC·∫≠u ch·ªâ m√¨nh ch·ªó n√†y v·ªõi ƒë∆∞·ª£c kh√¥ng?‚Äù",
            },
        },
        "general": {
            "neutral_replies": [
                "M√¨nh ch∆∞a r√µ l·∫Øm, b·∫°n n√≥i c·ª• th·ªÉ h∆°n ƒë∆∞·ª£c kh√¥ng?",
                "M√¨nh ƒëang nghe b·∫°n n√®, b·∫°n mu·ªën n√≥i th√™m ƒëi·ªÅu g√¨ kh√¥ng?"
            ],
            "follow_up_prompt": "B·∫°n mu·ªën ti·∫øp t·ª•c t√¢m s·ª± hay luy·ªán n√≥i chuy·ªán trong l·ªõp n√®?",
            "end_chat_replies": [
                "C·∫£m ∆°n b·∫°n ƒë√£ chia s·∫ª v·ªõi m√¨nh h√¥m nay nha. M√¨nh lu√¥n s·∫µn s√†ng khi b·∫°n c·∫ßn üíñ",
                "B·∫°n ƒë√£ l√†m r·∫•t t·ªët khi b·ªôc l·ªô c·∫£m x√∫c. Khi n√†o c·∫ßn, m√¨nh v·∫´n ·ªü ƒë√¢y ‚ú®"
            ],
        },
    }

CONFIG = get_config()

# Gemini optional
AI_ENABLED = False
if GENAI_AVAILABLE:
    try:
        genai.configure(api_key=st.secrets["GOOGLE_API_KEY"])
        gemini_model = genai.GenerativeModel("gemini-1.5-flash")
        AI_ENABLED = True
    except Exception as e:
        print(f"L·ªói c·∫•u h√¨nh Gemini: {e}")


# ========== 3) SESSION STATE ==========

if "page_state" not in st.session_state:
    st.session_state.page_state = STATE_CHAT
    st.session_state.chat_state = CHAT_STATE_MAIN
    st.session_state.history = [
        {"sender": "bot", "text": "Ch√†o b·∫°n, m√¨nh l√† B·∫°n ƒë·ªìng h√†nh ƒë√¢y! M√¨nh c√≥ th·ªÉ gi√∫p g√¨ cho b·∫°n h√¥m nay?"}
    ]
    st.session_state.turns = 0
    st.session_state.current_mood = None
    st.session_state.current_scenario = None
    st.session_state.user_input_buffer = ""  # d√πng v·ªõi chat_input

# Voice settings defaults
if "tts_enabled" not in st.session_state:
    st.session_state.tts_enabled = True
if "tts_voice" not in st.session_state:
    st.session_state.tts_voice = "vi-VN-HoaiMyNeural"  # n·ªØ
if "tts_rate" not in st.session_state:
    st.session_state.tts_rate = 0  # %

# ========== 4) TTS (EDGE TTS NEURAL + FALLBACK GTTS) ==========

@st.cache_data(show_spinner=False)
def gtts_bytes(text: str):
    if not GTTS_AVAILABLE:
        return None
    try:
        bio = BytesIO()
        tts = gTTS(text=text, lang="vi")
        tts.write_to_fp(bio)
        bio.seek(0)
        return bio.read()
    except Exception as e:
        print("L·ªói gTTS:", e)
        return None

async def _edge_tts_bytes_async(text: str, voice: str, rate_pct: int):
    if not EDGE_TTS_AVAILABLE:
        return None
    try:
        # rate like "+0%", "-10%", "+10%"
        rate_str = f"{'+' if rate_pct>=0 else ''}{rate_pct}%"
        communicate = edge_tts.Communicate(text, voice=voice, rate=rate_str)
        audio = b""
        async for chunk in communicate.stream():
            if chunk["type"] == "audio":
                audio += chunk["data"]
        return audio
    except Exception as e:
        print("L·ªói Edge TTS:", e)
        return None

@st.cache_data(show_spinner=False)
def edge_tts_bytes(text: str, voice: str, rate_pct: int):
    try:
        return asyncio.run(_edge_tts_bytes_async(text, voice, rate_pct))
    except RuntimeError:
        # In case event loop is already running (Streamlit quirk)
        loop = asyncio.new_event_loop()
        try:
            return loop.run_until_complete(_edge_tts_bytes_async(text, voice, rate_pct))
        finally:
            loop.close()
    except Exception as e:
        print("L·ªói ch·∫°y Edge TTS:", e)
        return None

def synthesize_tts(text: str, voice: str, rate_pct: int):
    # Prefer Edge TTS neural
    if EDGE_TTS_AVAILABLE:
        audio = edge_tts_bytes(text, voice, rate_pct)
        if audio:
            return audio
    # Fallback gTTS
    return gtts_bytes(text)

def autoplay_audio(audio_data: bytes):
    try:
        b64 = base64.b64encode(audio_data).decode()
        md = f"""
        <audio autoplay="true">
          <source src="data:audio/mp3;base64,{b64}" type="audio/mp3">
        </audio>
        """
        st.components.v1.html(md, height=0)
    except Exception as e:
        print("L·ªói ph√°t √¢m thanh:", e)


# ========== 5) LOGIC CHAT & AI ==========

def add_message(sender, text):
    st.session_state.history.append({"sender": sender, "text": text})

def detect_mood_from_text(text):
    cfg = CONFIG["tam_su"]["moods"]
    lowered = text.lower()
    tokens = set(re.findall(r"\b\w+\b", lowered))
    emojis = {"üòÑ", "üòî"}
    tokens.update(ch for ch in text if ch in emojis)
    best, score = None, 0
    for mood, m_cfg in cfg.items():
        kws = set(m_cfg["keywords"])
        matches = len(tokens.intersection(kws))
        if matches > score:
            best, score = mood, matches
    return best

def call_gemini(prompt: str) -> str:
    if not AI_ENABLED:
        return random.choice(CONFIG["general"]["neutral_replies"])
    try:
        contextual = (
            "H√£y tr·∫£ l·ªùi nh∆∞ m·ªôt ng∆∞·ªùi b·∫°n ƒë·ªìng h√†nh AI th√¢n thi·ªán, ki√™n nh·∫´n v√† th·∫•u hi·ªÉu d√†nh cho h·ªçc sinh."
            " Tr·∫£ l·ªùi b·∫±ng ti·∫øng Vi·ªát, ng·∫Øn g·ªçn v√† gi√†u ƒë·ªìng c·∫£m.\n\n"
            f"C√¢u h·ªèi/Chia s·∫ª c·ªßa ng∆∞·ªùi d√πng: '{prompt}'"
        )
        resp = gemini_model.generate_content(contextual)
        return resp.text or random.choice(CONFIG["general"]["neutral_replies"])
    except Exception as e:
        return f"Xin l·ªói, h·ªá th·ªëng ƒëang b·∫≠n. B·∫°n th·ª≠ l·∫°i sau nh√©. (Chi ti·∫øt: {e})"

def respond_bot(text: str):
    # Add bot message with typing effect
    with st.container():
        # Synthesize voice if enabled
        if st.session_state.tts_enabled:
            audio = synthesize_tts(text, st.session_state.tts_voice, st.session_state.tts_rate)
            if audio:
                autoplay_audio(audio)

    add_message("bot", text)

# ========== 6) GIAO DI·ªÜN CH√çNH (SHOPPING CHAT STYLE) ==========

with st.sidebar:
    st.markdown("### C√†i ƒë·∫∑t gi·ªçng n√≥i")
    st.session_state.tts_enabled = st.toggle("ƒê·ªçc to ph·∫£n h·ªìi", value=st.session_state.tts_enabled)
    voice = st.selectbox(
        "Gi·ªçng ƒë·ªçc",
        options=[
            "vi-VN-HoaiMyNeural (N·ªØ)",
            "vi-VN-NamMinhNeural (Nam)"
        ],
        index=0 if st.session_state.tts_voice.endswith("HoaiMyNeural") else 1
    )
    st.session_state.tts_voice = "vi-VN-HoaiMyNeural" if "HoaiMy" in voice else "vi-VN-NamMinhNeural"
    rate = st.slider("T·ªëc ƒë·ªô n√≥i (%)", -50, 50, st.session_state.tts_rate, step=5)
    st.session_state.tts_rate = rate

# Shell for chat
st.markdown('<div class="chat-shell">', unsafe_allow_html=True)

# Quick action chips (gi·ªëng app mua s·∫Øm c√≥ g·ª£i √Ω thao t√°c)
quick_actions_col = st.container()
with quick_actions_col:
    st.markdown('<div class="quick-actions">', unsafe_allow_html=True)
    qa_cols = st.columns(4)
    with qa_cols[0]:
        if st.button("üíñ T√¢m s·ª±", use_container_width=True):
            st.session_state.chat_state = CHAT_STATE_TAM_SU_SELECTION
            respond_bot(CONFIG["tam_su"]["intro_message"])
    with qa_cols[1]:
        if st.button("üó£Ô∏è Luy·ªán giao ti·∫øp", use_container_width=True):
            st.session_state.chat_state = CHAT_STATE_GIAO_TIEP_SELECTION_BASIC
            respond_bot(CONFIG["giao_tiep"]["intro_message"])
    with qa_cols[2]:
        if st.button("üìì Nh·∫≠t k√Ω", use_container_width=True):
            st.session_state.page_state = STATE_JOURNAL
    with qa_cols[3]:
        if st.button("üòå Th∆∞ gi√£n", use_container_width=True):
            st.session_state.page_state = STATE_RELAX
    st.markdown('</div>', unsafe_allow_html=True)

# Message history
for m in st.session_state.history:
    cls_row = "bubble-row bubble-user" if m["sender"] == "user" else "bubble-row"
    cls_msg = "msg msg-user" if m["sender"] == "user" else "msg msg-bot"
    st.markdown(
        f'<div class="{cls_row}"><div class="{cls_msg}">{html.escape(m["text"])}</div></div>',
        unsafe_allow_html=True
    )

# Suggested quick replies based on state (like shopping chat hints)
if st.session_state.chat_state == CHAT_STATE_TAM_SU_SELECTION:
    moods = list(CONFIG["tam_su"]["moods"].keys())
    st.caption("G·ª£i √Ω c·∫£m x√∫c:")
    cols = st.columns(len(moods))
    for i, mood in enumerate(moods):
        if cols[i].button(mood):
            st.session_state.chat_state = CHAT_STATE_TAM_SU_CHAT
            st.session_state.current_mood = mood
            st.session_state.turns = 0
            respond_bot(CONFIG["tam_su"]["moods"][mood]["initial"])

elif st.session_state.chat_state == CHAT_STATE_TAM_SU_CHAT:
    col1, col2 = st.columns(2)
    if col1.button(CONFIG["tam_su"]["positive_affirmation_trigger"], use_container_width=True):
        affirm = random.choice(CONFIG["tam_su"]["positive_affirmations"])
        st.session_state.chat_state = CHAT_STATE_MAIN
        respond_bot(affirm)
    if col2.button("üèÅ K·∫øt th√∫c", use_container_width=True):
        st.session_state.chat_state = CHAT_STATE_MAIN
        respond_bot(random.choice(CONFIG["general"]["end_chat_replies"]))

elif st.session_state.chat_state == CHAT_STATE_GIAO_TIEP_SELECTION_BASIC:
    st.caption("T√¨nh hu·ªëng c∆° b·∫£n:")
    for scenario in CONFIG["giao_tiep"]["scenarios_basic"].keys():
        if st.button(scenario, use_container_width=True):
            st.session_state.chat_state = CHAT_STATE_GIAO_TIEP_PRACTICE
            st.session_state.current_scenario = scenario
            respond_bot(CONFIG["giao_tiep"]["scenarios_basic"][scenario])

elif st.session_state.chat_state == CHAT_STATE_GIAO_TIEP_SELECTION_EXTENDED:
    st.caption("T√¨nh hu·ªëng n√¢ng cao:")
    for scenario in CONFIG["giao_tiep"]["scenarios_extended"].keys():
        if st.button(scenario, use_container_width=True):
            st.session_state.chat_state = CHAT_STATE_GIAO_TIEP_PRACTICE
            st.session_state.current_scenario = scenario
            respond_bot(CONFIG["giao_tiep"]["scenarios_extended"][scenario])

elif st.session_state.chat_state == CHAT_STATE_GIAO_TIEP_PRACTICE:
    b1, b2, b3 = st.columns(3)
    if b1.button(CONFIG["giao_tiep"]["confirm_buttons"]["understood"], use_container_width=True):
        st.session_state.chat_state = CHAT_STATE_GIAO_TIEP_SELECTION_EXTENDED
        respond_bot("Tuy·ªát v·ªùi! C√πng xem c√°c t√¨nh hu·ªëng m·ªü r·ªông nh√©!")
    if b2.button(CONFIG["giao_tiep"]["confirm_buttons"]["not_understood"], use_container_width=True):
        sc = st.session_state.current_scenario
        text = CONFIG["giao_tiep"]["scenarios_basic"].get(sc) or CONFIG["giao_tiep"]["scenarios_extended"].get(sc, "")
        respond_bot(f"Kh√¥ng sao c·∫£, m√¨nh n√≥i l·∫°i nh√©:\n\n{text}")
    if b3.button("‚èπÔ∏è D·ª´ng", use_container_width=True):
        st.session_state.chat_state = CHAT_STATE_MAIN
        respond_bot(random.choice(CONFIG["general"]["end_chat_replies"]))


# Chat input (modern, like shopping apps)
user_text = st.chat_input(CONFIG["ui"]["input_placeholder"])
if user_text:
    # Add user message
    add_message("user", user_text)
    st.session_state.turns += 1

    if st.session_state.chat_state == CHAT_STATE_TAM_SU_CHAT:
        mood = st.session_state.current_mood
        styles_all = sum(CONFIG["tam_su"]["moods"][mood]["styles"].values(), [])
        response_text = random.choice(styles_all)
        if st.session_state.turns >= 2:
            st.session_state.chat_state = CHAT_STATE_AWAITING_FOLLOWUP
            respond_bot(f"{response_text} {CONFIG['general']['follow_up_prompt']}")
        else:
            respond_bot(response_text)

    else:
        detected = detect_mood_from_text(user_text)
        if detected:
            st.session_state.chat_state = CHAT_STATE_TAM_SU_CHAT
            st.session_state.current_mood = detected
            st.session_state.turns = 0
            respond_bot(CONFIG["tam_su"]["moods"][detected]["initial"])
        else:
            # Call AI for open-ended stuff
            reply = call_gemini(user_text)
            st.session_state.chat_state = CHAT_STATE_AWAITING_FOLLOWUP
            respond_bot(reply)

# Close shell
st.markdown('</div>', unsafe_allow_html=True)

# Sticky input bar wrapper (purely visual; st.chat_input is already bottom-fixed by app flow)
st.markdown(
    """
<div class="input-bar">
  <div class="input-inner">
    <small style="color:#999">M·∫πo: B·∫°n c√≥ th·ªÉ b·∫•m c√°c g·ª£i √Ω nhanh ph√≠a tr√™n ƒë·ªÉ thao t√°c nhanh h∆°n.</small>
  </div>
</div>
""",
    unsafe_allow_html=True,
)


# ========== 7) ROUTER N·ªòI B·ªò: NH·∫¨T K√ù & TH∆Ø GI√ÉN ==========

def render_journal_ui():
    st.title("üìì Nh·∫≠t K√Ω C·∫£m X√∫c")
    MOOD_FILE = "mood_journal.csv"
    MOOD_OPTIONS = ["üòÑ Vui", "üòî Bu·ªìn", "üò† T·ª©c gi·∫≠n", "üò¥ M·ªát m·ªèi", "üòê B√¨nh th∆∞·ªùng"]

    def load_mood_data():
        if os.path.exists(MOOD_FILE):
            try:
                return pd.read_csv(MOOD_FILE)
            except pd.errors.EmptyDataError:
                pass
        return pd.DataFrame(columns=["Ng√†y", "C·∫£m x√∫c", "Ghi ch√∫"])

    journal_df = load_mood_data()
    st.header("H√¥m nay b·∫°n c·∫£m th·∫•y th·∫ø n√†o?")
    log_date = st.date_input("Ch·ªçn ng√†y", datetime.now())
    selected_mood = st.selectbox("Ch·ªçn c·∫£m x√∫c", MOOD_OPTIONS)
    note = st.text_input("Ghi ch√∫ th√™m?")
    if st.button("L∆∞u l·∫°i c·∫£m x√∫c"):
        new_entry = pd.DataFrame(
            [{"Ng√†y": log_date.strftime("%Y-%m-%d"), "C·∫£m x√∫c": selected_mood, "Ghi ch√∫": note}]
        )
        if not journal_df.empty:
            journal_df["Ng√†y"] = journal_df["Ng√†y"].astype(str)
            if log_date.strftime("%Y-%m-%d") in journal_df["Ng√†y"].values:
                st.warning("B·∫°n ƒë√£ ghi l·∫°i c·∫£m x√∫c cho ng√†y n√†y r·ªìi.")
            else:
                journal_df = pd.concat([journal_df, new_entry], ignore_index=True)
                journal_df.to_csv(MOOD_FILE, index=False)
                st.success("ƒê√£ l∆∞u!")
                st.rerun()
        else:
            journal_df = new_entry
            journal_df.to_csv(MOOD_FILE, index=False)
            st.success("ƒê√£ l∆∞u!")
            st.rerun()

    st.header("L·ªãch s·ª≠ c·∫£m x√∫c")
    if not journal_df.empty:
        st.dataframe(journal_df.sort_values(by="Ng√†y", ascending=False), use_container_width=True)
        st.header("Th·ªëng k√™ nhanh")
        st.bar_chart(journal_df["C·∫£m x√∫c"].value_counts())
    else:
        st.info("Nh·∫≠t k√Ω c·ªßa b·∫°n c√≤n tr·ªëng.")

    if st.button("‚¨ÖÔ∏è Quay l·∫°i tr√≤ chuy·ªán"):
        st.session_state.page_state = STATE_CHAT
        st.rerun()

def render_relax_ui():
    st.title("üòå G√≥c Th∆∞ Gi√£n")
    st.write("H√≠t th·ªü s√¢u, l·∫Øng nghe √¢m thanh nh·∫π nh√†ng.")
    st.header("B√†i t·∫≠p h√≠t th·ªü h·ªôp (4-4-4-4)")
    if st.button("B·∫Øt ƒë·∫ßu h√≠t th·ªü"):
        placeholder = st.empty()
        for i in range(3):
            placeholder.info("Chu·∫©n b·ªã..."); time.sleep(1)
        steps = [("H√≠t v√†o b·∫±ng m≈©i", 4), ("Gi·ªØ h∆°i", 4), ("Th·ªü ra b·∫±ng mi·ªáng", 4), ("Ngh·ªâ", 4)]
        for title, sec in steps:
            placeholder.success(f"{title} ({sec}s)"); time.sleep(sec)
        placeholder.success("Ho√†n th√†nh! B·∫°n th·∫•y t·ªët h∆°n ch·ª©?")

    st.header("√Çm thanh thi√™n nhi√™n")
    col1, col2, col3 = st.columns(3)
    with col1: st.video("https://www.youtube.com/watch?v=eKFTSSKCzWA")
    with col2: st.video("https://www.youtube.com/watch?v=gM_r4c6i25s")
    with col3: st.video("https://www.youtube.com/watch?v=aIIEI33EUqI")

    if st.button("‚¨ÖÔ∏è Quay l·∫°i tr√≤ chuy·ªán"):
        st.session_state.page_state = STATE_CHAT
        st.rerun()

# Router n·ªôi b·ªô
if st.session_state.page_state == STATE_JOURNAL:
    render_journal_ui()
elif st.session_state.page_state == STATE_RELAX:
    render_relax_ui()
# STATE_CHAT hi·ªÉn th·ªã ·ªü tr√™n
